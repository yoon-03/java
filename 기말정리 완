# 메소드
   메소드 규칙
    1. 숫자로 시작하면 안됨
    2. $와_를 제외한 특수문자를 사용하면 안됨
    3. 관례적으로 메소드명은 소문자로 작성
    4. 서로 다른 단어가 혼합된 이름이라면 뒤에 오는 단어의 첫글자는 대문자

메소드 호출
  클래스 내부 : 메소드 이름으로 호출
  클래스 외부 : 객체 생성 후, 참조 변수를 이용해서 호출

메소드 오버로딩
  클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
  하나의 메소드 이름으로 다양한 매개값을 받기 위해(ex public int num(string s) , public int num(string s, int i))
  조건: 매개변수의 타입, 개수 , 순서 중 하나라도 달라야함 

인스턴스 멤버
  this
    객체 자신의 참조를 가지고 있는 키워드
    객체 내부에서 인스턴스 멤버임을 명확히 하기 위해 this.사용 (this.model = model;)
    매개변수와 필드명이 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용

  인스턴스는 클래스로부터 생성된 개별적인 객체로 new키워드를 사용하여 객체를 생성할 때마다 힙메모리 영역에 할당됨
  접근 방법 = 객체.멤버이름 으로 접근 //Student student1 = new Student();

정적
  처음 설정되어 값을 바꾸지않고 그냥 출력  //System.out.println("값 :" + resource);

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 상속
  패키지 : 클래스를 기능별로 묶어서 그룹 이름을 붙여놓은 것 ( = 폴더)으로 클래스 이름의 일부 
          클래스 파일은 선언된 패키지와 동일한 폴더 안에서만 동작

  import문을 이용하여 다른 패키지에 있는 클래스를 사용함
  import Java.util.~~을 사용하여 스캐너를 사용하는 것을 생각
  import 문으로 지정된 패키지의 하위패키지는import 대상이 아님
  서로다른패키지에동일한이름의클래스가있는경우
  import 문을 사용하더라도 패키지 이름 전체를기술해야함

  접근제한자
    public: 전부 접근 가능      //라이브러리 클래스로 만들때 유용
    protected: 자식 클래스가 아닌 다른 패키지에 소속된 클래스
    default: 다른 패키지에 소속된 클래스 제외  //접근 제한자를 설정하지 않았을시 기본으로 설정됨
    private: 다른 모든 외부 클래스는 접근 불가


  클래스 선언 시 필드는 일반적으로 private 접근 제한
    읽기 전용 필드 (getter)
    외부에서 엉뚱한 값으로 변경할 수 없도록(setter)

  getter : private 필드의 값을 리턴하는 역할

  setter : 외부에서 주어진 값을 필드 값으로 수정

  extends를 사용하여 상속받음  //public class A extends A{ } (부모 클래스 나열 불가 (단일상속))
  상속의 효과
    부모 클래스를 재사용해서 자식 클래스를 빨리 개발 가능
    반복된 코드 중복을 줄임
    유지 보수 편리성 제공
    객체 다형성 구현이 가능 

상속 대상 제한
  부모 클래스의 private 접근을 갖는 필드와 메소드는 제외
  부모 클래스가 다른 패키지에 있을 경우  (default 접근을 갖는 필드와 메소드도 제외)  

명시적인 부모 생성자 호출 (Super) , this 와 비슷하나 차이 있음 (super는 부모 클래스의 멤버를 , this는 현재 클러스의 멤버)
  반드시 자식 생성자의 첫 줄에 기술
  부모 클래스에 기본 생성자가 없다면 반드시 작성
  부모 객체 생성 할 때, 부모 생성자를 선택해서 호출

메소드 재정의 (override)
  부모 클래스의 메소드를 자식 클래스에서 상속하여 재정의하는 것

  조건
    부모 클래스의 메소드와 동일한 모양을 가져야 함, 접근 제한을 더 강하게 오버라이딩 불가     

메소드 재정의 효과
  부모 메소드는 숨겨지는 효과
  재정의된 자식 클래스의 메소드가 실행됨

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 다형성
  같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질 , 객체 부품화가 가능

  자동타입 변환 : 프로그램 실행 도중에 자동으로 타입 변환이 일어나는 것
    바로 위의 부모가 아니더라도 상속 계층의 상위라면 자동 타입변환이 가능

  강제타입 변환 : 부모 타입을 자식 타입으로 변환하는것( 자식클래스 변수 = (자식클래스) 부모클래스타입, Cat cat = (Cat) Animal)
    강제타입 변환이 필요한 경우
      부모 타입으로 선언된 참조 변수가 자식 타입의 객체를 참조할 때

    모든 부모타입이 자식타입으로 강제타입변환 할수 있는 것이 아님(ClassCastException 예외 발생 가능)
    instanceof를 사용하여 자식타입인지 확인 후 진행( boolean result = 좌항(객체) instanceof 우항(타입))

  다형성: 동일한 타입을 사용하지만 다양한 결과가 나오는 성질
    구현조건 : 부모 클래스 상속, 메소드 오버라이딩, 부모타입으로 자동타입변환  

    매개변수의 다형성
      매개 변수가 클래스 타입인 경우 : 해당 클래스의 객체 대입이 원칙이나 자식객체 대입도 가능(자동타입변환 => 매개변수의 다형성 결과)

  추상 메소드 : 실행 내용이 자식 클래스마다 다른 메소드
    부모 클래스에는 메소드의 선언부만 작성, 부모 클래스의 메소드 앞에 abstract (abstract sound();), 자식 클래스에서 반드시 메소드 재정의

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 인터페이스
  객체의 사용방법을 정의한 타입, 객체의 교환성을 높여주기 떄문에 다형성을 구현하는 매우 중요한 역할을 담당, 개발 코드와 객체가 서로 연결되는 접점

  선언 : [접근제한자] interface 인터페이스명 { }
  인터페이스 이름 : 자바 식별자 작성 규칙에 따라 작성( 메소드 규칙)
  소스 파일 생성 : 인터페이스 이름과 대소문자가 동일한 소스 파일 생성

  인터페이스 구성 멤버 : 상수 필드, 추상 메소드, 디폴트 메소드, 정적 메소드 ( 인터페이스는 런타임 시 데이터를 저장할 수 있는 필드 선언불가)
    상수 필드 : 인터페이스는 상수 필드만 선언 가능, 선언된 필드는 모두 public static final(컴파일시 자동으로 붙음)
                상수명은 대문자로 작성(서로 다른 단어로 구성된 경우에는 _로 연결), 선언과 동시에 초기값을 지정
                상수 필드를 이용하여 유효성 검사 가능

    추상메소드 : 인터페이스의 메소드는 기본적으로 추상 메소드(실행 블록이 없음, public abstract를 생략해도 컴파일 시 붙음) - 인터페이스를 구현한 객체에서 반드시 재정의

    디폴트 메소드 : 실행 블록을 가지고 있는 메소드, 사용시 반드시 default 키워드를 붙임(public(생략가능) default 리턴타입 ~~~~){}
                    기본적으로 public 접근제한의 특성을 가짐, 모든 구현 객체가 가지고 있는 기본 메소드로 사용가능, 필요에 따라 구현 클래스가 재정의하여 사용
    정적 메소드 : 실행 블록을 반드시 가져야함, 메소드 선언시 static 키워드를 붙여야함, 기본적으로 public 접근 제한을 가짐, 인터페이스명.메소드명으로 호출, 오버라이딩 불

  인터페이스에 정의된 기능이 필요한 경우 클래스에서 구현하여 사용(첫줄에 public class 클래스명 implements 인터페이스명)
  인터페이스는 클래스와 달리 다중상속(하나 이상의 인터페이스 상속이 가능), 인터페이스 간의 상속도 가능

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 멀티스레드
  멀티 프로세스 : 여러 프로그램을 실행하고 여러 가지 작업 처리
  멀티 스레드 : 한개의 프로그램에서 내부적으로 여러 가지 작업 처리

  메인스레드 : 모든 자바 프로그램은 메인스레드가 main()메소드를 실행하며 첫코드부터 아래로 순차적으로 실행
  멀티스레드 기능을 사용하기 위해서는 Thread 클래스를 상속받아야함

  스레드 관련 명령어
    .sleep : 실행중인 스레드를 지정된 밀리초 동안 일시 정지 시킴
    .yield : 다른 스레드에게 실행 양보 후 실행 대기 상태로 전환
    .join : 다른 스레드의 종료를 기다림  (이 명령어로 순서대로 스레드 출력하게 할 수 있음)
    .wait : 동기화 블록 내에서 스레드를 일시 정지 상태로 만듦
    .notify : wait 메소드로 일시 정지 상태인 스레드를 실행 대기 상태로 만듦

  스레드 우선순위
    동시성 : 한번에 여러 작업을 하는 것처럼 보이나 실제로는 동시에 되는 것일 수도 있고 아니면 빠르게 전환하여 그렇게 보이는 것처럼 하는 것일수도 잇음
    병렬성 : 멀티코어를 사용하여 여러 작업을 동시에 실행함

    자바의 스레드 스케줄링은 우선순위 방식과 ROUND-ROBIN 방식 사용
      우선 순위 : 코드로 제어 가능, 우선 순위가 높은 스레드가 실행 상태를 많이 가지도록 스케줄링 우선순위는 1~10이고 기본은 5
      RR : 코드로 제어 불가, 시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼 실행

  동기화 메소드 : 하나의 객체를 공유할 경우 deadlock같은 문제가 발생할 수 있고 user1 = 100, user2 = 50일 때 둘다 50으로 출력될 수 있음
    동기화 메소드 및 동기화 블록 : synchronized(싱크로나이즈드) , 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하기 위해 작업이 끝날 때까지 잠금
                                  단 하나의 스레드만 실행할 수 있는 메소드, 다른 스레드는 메소드나 블록 실행이 끝날 떄까지 대기


